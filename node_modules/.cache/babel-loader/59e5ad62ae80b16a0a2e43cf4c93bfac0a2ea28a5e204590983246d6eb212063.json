{"ast":null,"code":"import { useLayoutEffect, useRef } from \"react\";\nimport { Animation } from \"./UI.js\";\nconst asHtmlElement = element => {\n  if (element instanceof HTMLElement) return element;\n  return null;\n};\nconst queryMonthEls = element => [...(element.querySelectorAll(\"[data-animated-month]\") ?? [])];\nconst queryMonthEl = element => asHtmlElement(element.querySelector(\"[data-animated-month]\"));\nconst queryCaptionEl = element => asHtmlElement(element.querySelector(\"[data-animated-caption]\"));\nconst queryWeeksEl = element => asHtmlElement(element.querySelector(\"[data-animated-weeks]\"));\nconst queryNavEl = element => asHtmlElement(element.querySelector(\"[data-animated-nav]\"));\nconst queryWeekdaysEl = element => asHtmlElement(element.querySelector(\"[data-animated-weekdays]\"));\n/** @private */\nexport function useAnimation(rootElRef, enabled, {\n  classNames,\n  months,\n  focused,\n  dateLib\n}) {\n  const previousRootElSnapshotRef = useRef(null);\n  const previousMonthsRef = useRef(months);\n  const animatingRef = useRef(false);\n  useLayoutEffect(() => {\n    // get previous months before updating the previous months ref\n    const previousMonths = previousMonthsRef.current;\n    // update previous months ref for next effect trigger\n    previousMonthsRef.current = months;\n    if (!enabled || !rootElRef.current ||\n    // safety check because the ref can be set to anything by consumers\n    !(rootElRef.current instanceof HTMLElement) ||\n    // validation required for the animation to work as expected\n    months.length === 0 || previousMonths.length === 0 || months.length !== previousMonths.length) {\n      return;\n    }\n    const isSameMonth = dateLib.isSameMonth(months[0].date, previousMonths[0].date);\n    const isAfterPreviousMonth = dateLib.isAfter(months[0].date, previousMonths[0].date);\n    const captionAnimationClass = isAfterPreviousMonth ? classNames[Animation.caption_after_enter] : classNames[Animation.caption_before_enter];\n    const weeksAnimationClass = isAfterPreviousMonth ? classNames[Animation.weeks_after_enter] : classNames[Animation.weeks_before_enter];\n    // get previous root element snapshot before updating the snapshot ref\n    const previousRootElSnapshot = previousRootElSnapshotRef.current;\n    // update snapshot for next effect trigger\n    const rootElSnapshot = rootElRef.current.cloneNode(true);\n    if (rootElSnapshot instanceof HTMLElement) {\n      // if this effect is triggered while animating, we need to clean up the new root snapshot\n      // to put it in the same state as when not animating, to correctly animate the next month change\n      const currentMonthElsSnapshot = queryMonthEls(rootElSnapshot);\n      currentMonthElsSnapshot.forEach(currentMonthElSnapshot => {\n        if (!(currentMonthElSnapshot instanceof HTMLElement)) return;\n        // remove the old month snapshots from the new root snapshot\n        const previousMonthElSnapshot = queryMonthEl(currentMonthElSnapshot);\n        if (previousMonthElSnapshot && currentMonthElSnapshot.contains(previousMonthElSnapshot)) {\n          currentMonthElSnapshot.removeChild(previousMonthElSnapshot);\n        }\n        // remove animation classes from the new month snapshots\n        const captionEl = queryCaptionEl(currentMonthElSnapshot);\n        if (captionEl) {\n          captionEl.classList.remove(captionAnimationClass);\n        }\n        const weeksEl = queryWeeksEl(currentMonthElSnapshot);\n        if (weeksEl) {\n          weeksEl.classList.remove(weeksAnimationClass);\n        }\n      });\n      previousRootElSnapshotRef.current = rootElSnapshot;\n    } else {\n      previousRootElSnapshotRef.current = null;\n    }\n    if (animatingRef.current || isSameMonth ||\n    // skip animation if a day is focused because it can cause issues to the animation and is better for a11y\n    focused) {\n      return;\n    }\n    const previousMonthEls = previousRootElSnapshot instanceof HTMLElement ? queryMonthEls(previousRootElSnapshot) : [];\n    const currentMonthEls = queryMonthEls(rootElRef.current);\n    if (currentMonthEls && currentMonthEls.every(el => el instanceof HTMLElement) && previousMonthEls && previousMonthEls.every(el => el instanceof HTMLElement)) {\n      animatingRef.current = true;\n      const cleanUpFunctions = [];\n      // set isolation to isolate to isolate the stacking context during animation\n      rootElRef.current.style.isolation = \"isolate\";\n      // set z-index to 1 to ensure the nav is clickable over the other elements being animated\n      const navEl = queryNavEl(rootElRef.current);\n      if (navEl) {\n        navEl.style.zIndex = \"1\";\n      }\n      currentMonthEls.forEach((currentMonthEl, index) => {\n        const previousMonthEl = previousMonthEls[index];\n        if (!previousMonthEl) {\n          return;\n        }\n        // animate new displayed month\n        currentMonthEl.style.position = \"relative\";\n        currentMonthEl.style.overflow = \"hidden\";\n        const captionEl = queryCaptionEl(currentMonthEl);\n        if (captionEl) {\n          captionEl.classList.add(captionAnimationClass);\n        }\n        const weeksEl = queryWeeksEl(currentMonthEl);\n        if (weeksEl) {\n          weeksEl.classList.add(weeksAnimationClass);\n        }\n        // animate new displayed month end\n        const cleanUp = () => {\n          animatingRef.current = false;\n          if (rootElRef.current) {\n            rootElRef.current.style.isolation = \"\";\n          }\n          if (navEl) {\n            navEl.style.zIndex = \"\";\n          }\n          if (captionEl) {\n            captionEl.classList.remove(captionAnimationClass);\n          }\n          if (weeksEl) {\n            weeksEl.classList.remove(weeksAnimationClass);\n          }\n          currentMonthEl.style.position = \"\";\n          currentMonthEl.style.overflow = \"\";\n          if (currentMonthEl.contains(previousMonthEl)) {\n            currentMonthEl.removeChild(previousMonthEl);\n          }\n        };\n        cleanUpFunctions.push(cleanUp);\n        // animate old displayed month\n        previousMonthEl.style.pointerEvents = \"none\";\n        previousMonthEl.style.position = \"absolute\";\n        previousMonthEl.style.overflow = \"hidden\";\n        previousMonthEl.setAttribute(\"aria-hidden\", \"true\");\n        // hide the weekdays container of the old month and only the new one\n        const previousWeekdaysEl = queryWeekdaysEl(previousMonthEl);\n        if (previousWeekdaysEl) {\n          previousWeekdaysEl.style.opacity = \"0\";\n        }\n        const previousCaptionEl = queryCaptionEl(previousMonthEl);\n        if (previousCaptionEl) {\n          previousCaptionEl.classList.add(isAfterPreviousMonth ? classNames[Animation.caption_before_exit] : classNames[Animation.caption_after_exit]);\n          previousCaptionEl.addEventListener(\"animationend\", cleanUp);\n        }\n        const previousWeeksEl = queryWeeksEl(previousMonthEl);\n        if (previousWeeksEl) {\n          previousWeeksEl.classList.add(isAfterPreviousMonth ? classNames[Animation.weeks_before_exit] : classNames[Animation.weeks_after_exit]);\n        }\n        currentMonthEl.insertBefore(previousMonthEl, currentMonthEl.firstChild);\n      });\n    }\n  });\n}","map":{"version":3,"names":["useLayoutEffect","useRef","Animation","asHtmlElement","element","HTMLElement","queryMonthEls","querySelectorAll","queryMonthEl","querySelector","queryCaptionEl","queryWeeksEl","queryNavEl","queryWeekdaysEl","useAnimation","rootElRef","enabled","classNames","months","focused","dateLib","previousRootElSnapshotRef","previousMonthsRef","animatingRef","previousMonths","current","length","isSameMonth","date","isAfterPreviousMonth","isAfter","captionAnimationClass","caption_after_enter","caption_before_enter","weeksAnimationClass","weeks_after_enter","weeks_before_enter","previousRootElSnapshot","rootElSnapshot","cloneNode","currentMonthElsSnapshot","forEach","currentMonthElSnapshot","previousMonthElSnapshot","contains","removeChild","captionEl","classList","remove","weeksEl","previousMonthEls","currentMonthEls","every","el","cleanUpFunctions","style","isolation","navEl","zIndex","currentMonthEl","index","previousMonthEl","position","overflow","add","cleanUp","push","pointerEvents","setAttribute","previousWeekdaysEl","opacity","previousCaptionEl","caption_before_exit","caption_after_exit","addEventListener","previousWeeksEl","weeks_before_exit","weeks_after_exit","insertBefore","firstChild"],"sources":["C:/Users/JOSEPH/Desktop/web/node_modules/react-day-picker/dist/esm/useAnimation.js"],"sourcesContent":["import { useLayoutEffect, useRef } from \"react\";\nimport { Animation } from \"./UI.js\";\nconst asHtmlElement = (element) => {\n    if (element instanceof HTMLElement)\n        return element;\n    return null;\n};\nconst queryMonthEls = (element) => [\n    ...(element.querySelectorAll(\"[data-animated-month]\") ?? [])\n];\nconst queryMonthEl = (element) => asHtmlElement(element.querySelector(\"[data-animated-month]\"));\nconst queryCaptionEl = (element) => asHtmlElement(element.querySelector(\"[data-animated-caption]\"));\nconst queryWeeksEl = (element) => asHtmlElement(element.querySelector(\"[data-animated-weeks]\"));\nconst queryNavEl = (element) => asHtmlElement(element.querySelector(\"[data-animated-nav]\"));\nconst queryWeekdaysEl = (element) => asHtmlElement(element.querySelector(\"[data-animated-weekdays]\"));\n/** @private */\nexport function useAnimation(rootElRef, enabled, { classNames, months, focused, dateLib }) {\n    const previousRootElSnapshotRef = useRef(null);\n    const previousMonthsRef = useRef(months);\n    const animatingRef = useRef(false);\n    useLayoutEffect(() => {\n        // get previous months before updating the previous months ref\n        const previousMonths = previousMonthsRef.current;\n        // update previous months ref for next effect trigger\n        previousMonthsRef.current = months;\n        if (!enabled ||\n            !rootElRef.current ||\n            // safety check because the ref can be set to anything by consumers\n            !(rootElRef.current instanceof HTMLElement) ||\n            // validation required for the animation to work as expected\n            months.length === 0 ||\n            previousMonths.length === 0 ||\n            months.length !== previousMonths.length) {\n            return;\n        }\n        const isSameMonth = dateLib.isSameMonth(months[0].date, previousMonths[0].date);\n        const isAfterPreviousMonth = dateLib.isAfter(months[0].date, previousMonths[0].date);\n        const captionAnimationClass = isAfterPreviousMonth\n            ? classNames[Animation.caption_after_enter]\n            : classNames[Animation.caption_before_enter];\n        const weeksAnimationClass = isAfterPreviousMonth\n            ? classNames[Animation.weeks_after_enter]\n            : classNames[Animation.weeks_before_enter];\n        // get previous root element snapshot before updating the snapshot ref\n        const previousRootElSnapshot = previousRootElSnapshotRef.current;\n        // update snapshot for next effect trigger\n        const rootElSnapshot = rootElRef.current.cloneNode(true);\n        if (rootElSnapshot instanceof HTMLElement) {\n            // if this effect is triggered while animating, we need to clean up the new root snapshot\n            // to put it in the same state as when not animating, to correctly animate the next month change\n            const currentMonthElsSnapshot = queryMonthEls(rootElSnapshot);\n            currentMonthElsSnapshot.forEach((currentMonthElSnapshot) => {\n                if (!(currentMonthElSnapshot instanceof HTMLElement))\n                    return;\n                // remove the old month snapshots from the new root snapshot\n                const previousMonthElSnapshot = queryMonthEl(currentMonthElSnapshot);\n                if (previousMonthElSnapshot &&\n                    currentMonthElSnapshot.contains(previousMonthElSnapshot)) {\n                    currentMonthElSnapshot.removeChild(previousMonthElSnapshot);\n                }\n                // remove animation classes from the new month snapshots\n                const captionEl = queryCaptionEl(currentMonthElSnapshot);\n                if (captionEl) {\n                    captionEl.classList.remove(captionAnimationClass);\n                }\n                const weeksEl = queryWeeksEl(currentMonthElSnapshot);\n                if (weeksEl) {\n                    weeksEl.classList.remove(weeksAnimationClass);\n                }\n            });\n            previousRootElSnapshotRef.current = rootElSnapshot;\n        }\n        else {\n            previousRootElSnapshotRef.current = null;\n        }\n        if (animatingRef.current ||\n            isSameMonth ||\n            // skip animation if a day is focused because it can cause issues to the animation and is better for a11y\n            focused) {\n            return;\n        }\n        const previousMonthEls = previousRootElSnapshot instanceof HTMLElement\n            ? queryMonthEls(previousRootElSnapshot)\n            : [];\n        const currentMonthEls = queryMonthEls(rootElRef.current);\n        if (currentMonthEls &&\n            currentMonthEls.every((el) => el instanceof HTMLElement) &&\n            previousMonthEls &&\n            previousMonthEls.every((el) => el instanceof HTMLElement)) {\n            animatingRef.current = true;\n            const cleanUpFunctions = [];\n            // set isolation to isolate to isolate the stacking context during animation\n            rootElRef.current.style.isolation = \"isolate\";\n            // set z-index to 1 to ensure the nav is clickable over the other elements being animated\n            const navEl = queryNavEl(rootElRef.current);\n            if (navEl) {\n                navEl.style.zIndex = \"1\";\n            }\n            currentMonthEls.forEach((currentMonthEl, index) => {\n                const previousMonthEl = previousMonthEls[index];\n                if (!previousMonthEl) {\n                    return;\n                }\n                // animate new displayed month\n                currentMonthEl.style.position = \"relative\";\n                currentMonthEl.style.overflow = \"hidden\";\n                const captionEl = queryCaptionEl(currentMonthEl);\n                if (captionEl) {\n                    captionEl.classList.add(captionAnimationClass);\n                }\n                const weeksEl = queryWeeksEl(currentMonthEl);\n                if (weeksEl) {\n                    weeksEl.classList.add(weeksAnimationClass);\n                }\n                // animate new displayed month end\n                const cleanUp = () => {\n                    animatingRef.current = false;\n                    if (rootElRef.current) {\n                        rootElRef.current.style.isolation = \"\";\n                    }\n                    if (navEl) {\n                        navEl.style.zIndex = \"\";\n                    }\n                    if (captionEl) {\n                        captionEl.classList.remove(captionAnimationClass);\n                    }\n                    if (weeksEl) {\n                        weeksEl.classList.remove(weeksAnimationClass);\n                    }\n                    currentMonthEl.style.position = \"\";\n                    currentMonthEl.style.overflow = \"\";\n                    if (currentMonthEl.contains(previousMonthEl)) {\n                        currentMonthEl.removeChild(previousMonthEl);\n                    }\n                };\n                cleanUpFunctions.push(cleanUp);\n                // animate old displayed month\n                previousMonthEl.style.pointerEvents = \"none\";\n                previousMonthEl.style.position = \"absolute\";\n                previousMonthEl.style.overflow = \"hidden\";\n                previousMonthEl.setAttribute(\"aria-hidden\", \"true\");\n                // hide the weekdays container of the old month and only the new one\n                const previousWeekdaysEl = queryWeekdaysEl(previousMonthEl);\n                if (previousWeekdaysEl) {\n                    previousWeekdaysEl.style.opacity = \"0\";\n                }\n                const previousCaptionEl = queryCaptionEl(previousMonthEl);\n                if (previousCaptionEl) {\n                    previousCaptionEl.classList.add(isAfterPreviousMonth\n                        ? classNames[Animation.caption_before_exit]\n                        : classNames[Animation.caption_after_exit]);\n                    previousCaptionEl.addEventListener(\"animationend\", cleanUp);\n                }\n                const previousWeeksEl = queryWeeksEl(previousMonthEl);\n                if (previousWeeksEl) {\n                    previousWeeksEl.classList.add(isAfterPreviousMonth\n                        ? classNames[Animation.weeks_before_exit]\n                        : classNames[Animation.weeks_after_exit]);\n                }\n                currentMonthEl.insertBefore(previousMonthEl, currentMonthEl.firstChild);\n            });\n        }\n    });\n}\n//# sourceMappingURL=useAnimation.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}